---
layout: post
title: Async RAT - Analysis
date: 15-02-2025
categories: [Malware, RATs]
tag: [Malware, RATs]
---

![Banner AsyncRAT](assets/images/blogs/async-rat/Banner-async.png)

AsyncRAT is a remote access trojan (RAT) built to remotely monitor and control other computers through a secure, encrypted connection. The name "AsyncRAT" comes from its core functionalityâ€”'async' means it performs its operations asynchronously, which means it is capable of executing several tasks simultaneously. AsyncRAT has been observed as being bought, sold, and deployed for years, going through many versions and renditions. Functionality associated with AsyncRAT includes keylogging, remote desktop control, and the ability to enumerate a victim machine and exfiltraing stolen data - among other fucntionality.

In this post, we'll look at the newest version or AsyncRAT, and use this as an opportunity to document what a good process for analysing a trojan looks like. We'll also go over what to expect in terms of output, that being the tangible things we get from analysing trojans.

And I promise that by the end of this you won't look like our Skaven friend, pictured below. I am a huge Warhammer nerd so I expect little bits with filter into the blogs!

<img src="assets/images/blogs/async-rat/skaven-scientist.png" alt="Skaven Scientist" width="500" height="500">

## Initialisation

In January 2019 AsyncRAT was released as an open source remote administration tool project on [GitHub](https://github.com/NYAN-x-CAT/AsyncRAT-C-Sharp). Since then, threat actors and adversaries have used several interesting script loaders and spear phishing attachments to deliver AsyncRAT to targeted hosts or networks in different campaigns over the years. Though, this blog will focus specifically on AsyncRAT rather than the delivery mechanisms used throughout the many campaigns that use this trojan.

AsyncRAT begins it's execution process by sleeping for one second before going through the rest of its initialisation, it is unclear why this happens. In addition, AsyncRAT initialises itself using its settings, and if this errors in any way, AsyncRAT terminates.

```cs
{
	}
	for (int i = 0; i < Convert.ToInt32(Settings.Delay); i++)
	{
		Thread.Sleep(1000);
	}
	if (!Settings.InitializeSettings())
	{
		Environment.Exit(0);
}
```

The `InitializeSettings` method shows that the malware's configuration is Base64 decoded and AES encrypted. This configuration is decoded and decrypted before use, as shown in the code block below:

```cs
{
	bool flag;
		try
		{
		Settings.Key = Encoding.UTF8.GetString(Convert.FromBase64String(Settings.Key));
		Settings.aes256 = new Aes256(Settings.Key);
		Settings.Ports = Settings.aes256.Decrypt(Settings.Ports);
		Settings.Hosts = Settings.aes256.Decrypt(Settings.Hosts);
		Settings.Version = Settings.aes256.Decrypt(Settings.Version);
		Settings.Install = Settings.aes256.Decrypt(Settings.Install);
		Settings.MTX = Settings.aes256.Decrypt(Settings.MTX);
		Settings.Pastebin = Settings.aes256.Decrypt(Settings.Pastebin);
		Settings.Anti = Settings.aes256.Decrypt(Settings.Anti);
		Settings.BDOS = Settings.aes256.Decrypt(Settings.BDOS);
		Settings.Group = Settings.aes256.Decrypt(Settings.Group);
		Settings.Hwid = HwidGen.HWID();
		Settings.Serversignature = Settings.aes256.Decrypt(Settings.Serversignature);
		Settings.ServerCertificate = new X509Certificate2(Convert.FromBase64String(Settings.aes256.Decrypt(Settings.Certificate)));
		flag = Settings.VerifyHash();
		}
		catch
		{
		flag = false;
		}
		return flag;
}
```

As shown in the picture below, the configurations used by the malware, such as the C2 host and ports are indeed encrypted and encoded.

![AsyncRAT config](assets/images/blogs/async-rat/async-config.png)

One of the main goals when analysing trojans is to identify and extract this configuration information, as it's quite telling as to how the malware is built. This will become more apparent later when I dicuss the server side operations, the builder, and how the config structure for AsyncRAT is exactly the same sample to sample, even if the values are different (as many of them are set by the attacker).

One other things to mention is the `flag = Settings.VerifyHash();` check in the code block above. AsyncRAT needs to verify the integrity of it's configurations and return a `true` result. If `false`, AsyncRAT will terminate. The malware also checks if any of the configurations have been changed post compilation, by using `Serversignature` and `ServerCertificate` with the `VerifyHash` function - returning the result. This works like a watermark for wants of a better example. Without this check, we could reverse engineer the malware allot faster since I could manually put in whatever values I wanted by editing the methods, and I'd be able to see the malware's functionality that way.

## Encryption and Decryption Routine

Insofar as the encrpytion and decryption routine goes, it is reasonbly straightforward and doesn't differ too much from other RAT configurations, the decryption routine for the latest version of ASyncRAT is shown below:

![AsyncRAT config](assets/images/blogs/async-rat/async-decrypt.png)

This is how the full decrpytion routine works:

* The function `Decrypt` takes a byte array (`byte[] input`) as its argument. This is likely the encrypted data that needs to be decrypted.
* It then checks if the input is null. If null, it throws an `ArgumentNullException`, indicating that the input argument can not be null.
* A `MemoryStream` object is created with the input data. `MemoryStream` is a stream that stores data in memory.
* An `AesCryptoServiceProvider` object is created, which provides AES encryption and decryption services. KeySize is set to 256 bits, BlockSize is set to 128 bits, mode is set to `CipherMode.CBC` (Cipher Block Chaining), and the method of padding is set to `PKCS7` (Public Key Cryptography Standards #7).
* A key is provided for the AES algorithm with `aesCryptoServiceProvider.Key = this._key`. The key itself can be found in AsyncRAT's configuration, more on this later.
* It then calculates a `HMACSHA256` hash for `memoryStream` array excluding the HMAC itself (present in first 32 bytes), resulting in array.
* It reads the HMAC from `memoryStream` (first 32 bytes) and compares it with just calculated HMAC array. If they are not equal, it throws a `CryptographicException` indicating an "Invalid message authentication code (MAC)".
* It then reads the next 16 bytes (representing the Initialization Vector (IV)) from the memoryStream into `array3`, and sets `aesCryptoServiceProvider.IV` to `array3`.
* It reads decrypted data from a `CryptoStream` object into `array4` and array5. The `CryptoStream` is initialized with the previously mentioned `MemoryStream` and the AES decryption object created before.
* `Buffer.BlockCopy` is then used to copy the decrypted data (stored in `array4`) into `array5`, starting from the start until the end of the decrypted data's length.
`array5` is assigned to `array6`.
* After all of this, the function returns `array6`, which holds the decrypted byte array.











## Anti-analysis and defence evasion

## Persistence

## Installation

## BSOD

## Command and Control (C2)

## Server Side Ops

## Detection and Mitigation

## Conclusion


